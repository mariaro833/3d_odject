<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
	<link rel="stylesheet" href="styles.css">
    <title>Cylinder</title>
</head>

<body>

	<h1>GEOMETRICAL OBJECT FOR ROBOTIC 3D-PRINTING <br> 2D-model</h1>

	<canvas id="myCanvas" width="500" height="500" style="border:1px solid #ffccff;">
	Your browser does not support the canvas element.
	</canvas>

	<br>
	<h2 class="special">Arguments.<br>Please specify the parameters for the geometrical object:<span> diameter, height, width of the layer </span></h2>

<p class="special">
	Diameter: <input type="number" id="diameter" value="200"><br>
<!-- D2: <input type="number" id="radius2" value="180"><br> -->
	Height: <input type="number" id="height1" value="200"><br>
	Width_of_the_layer: <input type="number" id="width_l" value="3"></p><br>

<h3 class="special">Calculated parameters:</h3>

segments: <input type="number" id="segments" value="21"><br><br>

scale: <input type="number" id="scale" value=1.0>
alpha: <input type="number" id="alpha1" value=0><br>

<p>
<button onclick="updateMyCanvas()">Update</button>
</p>

<script>

var canvas = document.getElementById("myCanvas");
var context = canvas.getContext("2d");

updateMyCanvas()

function  updateMyCanvas() {

	context.clearRect(0, 0, canvas.width, canvas.height)

	let diameter = document.getElementById("diameter").value
	let h = document.getElementById("height1").value

	var scale = document.getElementById("scale").value
	if (scale < 0.1) {
		scale = 0.1
		document.getElementById("scale").value = 0.1
	}
	if (h >= 300 || diameter >= 300) {
		scale = 0.4
		document.getElementById("scale").value = 0.6
	}

	let alpha1 = document.getElementById("alpha1").value
	let center1 = [250,200]
	// let width_l = document.getElementById("width_l").value * scale
	let radius1 = (diameter / 2 - 3) * scale
	h1 = h * scale

	// let offset
	// let radius2
	// if (h1 < 150 || radius1 < 75) {
	// 		offset = 0;
	// 		radius2 = 0;
	// 		h2 = 0;
	// 	}
	// else {
	// 	offset = h1 * 0.04;
	// 	radius2 = radius1 - offset - width_l
	// }

	let alpha2 = alpha1
	let center2 = center1
	let radius2
	let width_l

	if (diameter >= 80 && diameter < 220)
		width_l = 3;
	if (diameter >= 220 && diameter < 360)
		width_l = 4;
	if (diameter >= 360 && diameter < 500)
		width_l = 5;
	if (diameter == 500)
		width_l = 6;

	if (h >= 150 && (diameter >= 150)) {
		radius2 = radius1 - h1 * 0.04 - width_l
	// let radius2 = document.getElementById("radius2").value * scale
		h2 = h1
	}

	let segments = document.getElementById("segments").value
	//draw2Ellipse(context, [200,200], [100,50], [50,25], [0, Math.PI*2], alpha1,'green')

	let diameter1 = radius1 * 2
	let diameter2 = radius2 * 2

	drawCylinder(context, center1, diameter1, h1,  alpha1, 'blue')
	drawCylinder(context, center2, diameter2, h2,  alpha2, 'orange')
	draw2Ellipse(context, center1,
		[diameter1,diameter1*scaleAxis],
		[diameter2,diameter2*scaleAxis],
		[0, Math.PI*2], alpha1,'blue',segments)

}

function drawCylinder(ctx, center, r, h, angle, color, segments) {
	scaleAxis = 0.45
	drawEllipse(context, center,[r,r*scaleAxis], [0, Math.PI*2], angle, color)
	drawEllipse(context, [center[0]-h*Math.sin(angle),center[1]+h*Math.cos(angle)],[r,r*scaleAxis], [0, Math.PI], angle, color)
	ctx.beginPath();

	let left = [center[0]-r*Math.cos(angle),center[1]-r*Math.sin(angle)]
	ctx.moveTo(left[0],left[1])
	ctx.lineTo(left[0]-h*Math.sin(angle),left[1]+h*Math.cos(angle))

	let right = [center[0]+r*Math.cos(angle),center[1]+r*Math.sin(angle)]
	ctx.moveTo(right[0],right[1])
	ctx.lineTo(right[0]-h*Math.sin(angle),right[1]+h*Math.cos(angle))

	ctx.stroke();
	ctx.closePath();
	}

function drawEllipse(ctx, center, sizes, sector, angle, color) {
	ctx.save();                                     // сохраняем стейт контекста
	ctx.beginPath();
	ctx.translate(center[0], center[1]);            // перемещаем координаты в центр эллипса
	ctx.rotate(angle);                              // поворачиваем координатную сетку на нужный угол
	ctx.scale(1, sizes[1]/sizes[0]);                // сжимаем по вертикали
	ctx.arc(0, 0, sizes[0], sector[0], sector[1]);  // рисуем сектор окружности
	ctx.restore();                                  // восстанавливает стейт, иначе обводка и заливка будут сплющенными и повёрнутыми
	ctx.strokeStyle = color;
	ctx.stroke();                                   // обводим
	ctx.closePath();
}

function draw2Ellipse(ctx, center, sizes, sizes2, sector, angle, color, segments) {
	ctx.save();                                     // сохраняем стейт контекста
	ctx.beginPath();
	ctx.translate(center[0], center[1]);            // перемещаем координаты в центр эллипса
	ctx.rotate(angle);                              // поворачиваем координатную сетку на нужный угол
	ctx.scale(1, sizes[1]/sizes[0]);                // сжимаем по вертикали
	// два кольца, можем не рисовать
	// ctx.arc(0, 0, sizes[0], sector[0], sector[1]);  // рисуем сектор окружности
	// ctx.moveTo(sizes2[0],0)
	// ctx.arc(0, 0, sizes2[0],sector[0], sector[1]);  // рисуем сектор окружности

	//зигзаг между кольцами )

	var x, y, firstTime=true;
	var dt = 2*Math.PI/segments;
	for(var t=0; t < 2*Math.PI; t+=dt) {
		if(firstTime) {
			x = sizes[0]*Math.cos(t);
			y = sizes[0]*Math.sin(t);
			firstTime = false;
			ctx.moveTo(x, y);
			x = sizes2[0]*Math.cos(t+dt/2);
			y = sizes2[0]*Math.sin(t+dt/2);
			ctx.lineTo(x, y);
			} else
		{
			x = sizes[0]*Math.cos(t);
			y = sizes[0]*Math.sin(t);
			ctx.lineTo(x, y);
			x = sizes2[0]*Math.cos(t+dt/2);
			y = sizes2[0]*Math.sin(t+dt/2);
			ctx.lineTo(x, y);
		}
	}
	x = sizes[0]*Math.cos(0);
	y = sizes[0]*Math.sin(t);
	ctx.lineTo(x, y);

	ctx.restore();                                  // восстанавливает стейт, иначе обводка и заливка будут сплющенными и повёрнутыми
	ctx.strokeStyle = color;
	ctx.stroke();                                   // обводим
	ctx.closePath();
}

</script>
</body>
</html>

