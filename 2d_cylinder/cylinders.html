<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
	<link rel="stylesheet" href="styles.css">
    <title>Cylinder</title>
</head>

<body>

	<h1>GEOMETRICAL OBJECT FOR ROBOTIC 3D-PRINTING <br> 2D-model</h1>

	<canvas id="myCanvas" width="500" height="500" style="border:1px solid #ffccff;">
	Your browser does not support the canvas element.
	</canvas>

	<br>
	<h2 class="special">Arguments.<br>Please specify the parameters for the geometrical object:<span> diameter, height, width of the layer </span></h2>

<p class="special">
	Diameter: <input type="number" id="diameter" value="200"><br>
	Height: <input type="number" id="height" value="200"><br>
	Width_of_the_layer: <input type="number" id="width_l" value="3"><br><br>
	Zigzag, number of segments: <input type="number" id="segments" value="21"><br>
	Rotation: <input type="number" id="alpha1" value=0></p>

<!-- <h3 class="special">Calculated parameters:</h3>

scale: <input type="number" id="scale" value=1.0> -->

<p>
	<button onclick="updateMyCanvas()">Update</button></p>

	<p class="special">scale: <input type="number" id="scale" value=1.0></p>

<script>

var canvas = document.getElementById("myCanvas");
var context = canvas.getContext("2d");

updateMyCanvas()

function  updateMyCanvas() {

	context.clearRect(0, 0, canvas.width, canvas.height)

	let diameter = document.getElementById("diameter").value
	let h = document.getElementById("height").value

	/* height of the Object input checker */
	let min_h
	if (diameter < 100) {
		min_h = 100
	}
	if (diameter >= 100) {
		min_h = diameter
	}
	let max_h
	if (diameter * 1.5 > 500) {
		max_h = 500;
	}
	else {
		max_h = diameter * 1.5
	}

	if (h < min_h || h > max_h)
		h = prompt("Ration of height to diameter is 1:1 - 1:1.5", min_h)
	document.getElementById("height").value = h

	var scale = 1
	if (scale < 0.1) {
		scale = 0.1
		document.getElementById("scale").value = 0.1
	}
	if (h >= 300 || diameter >= 300) {
		scale = 0.4
		document.getElementById("scale").value = 0.6
	}

	let alpha1 = document.getElementById("alpha1").value
	let center1 = [250,200]
	// let width_l = document.getElementById("width_l").value * scale
	let radius1 = (diameter / 2 - 3) * scale
	h1 = h * scale

	let alpha2 = alpha1
	let center2 = center1
	let radius2
	let width_l

	/* Width of the layer calculation depending on the diameter od the Object */
	if (diameter >= 80 && diameter < 220)
		width_l = 3;
	if (diameter >= 220 && diameter < 360)
		width_l = 4;
	if (diameter >= 360 && diameter < 500)
		width_l = 5;
	if (diameter == 500)
		width_l = 6;

	/* Offset calculation depending on the diameter of the Object */
	let offset = h1 * 0.04;

	/* Radius and height for the second cylinder calculations */
	if (h >= 150 && (diameter >= 150)) {
		radius2 = radius1 - offset - width_l
		h2 = h1
	}

	let segments = document.getElementById("segments").value
	//draw2Ellipse(context, [200,200], [100,50], [50,25], [0, Math.PI*2], alpha1,'green')

	let diameter1 = radius1 * 2
	let diameter2 = radius2 * 2

	drawCylinder(context, center1, diameter1, h1,  alpha1, 'blue')
	drawCylinder(context, center2, diameter2, h2,  alpha2, 'orange')
	draw2Ellipse(context, center1,
		[diameter1,diameter1*scaleAxis],
		[diameter2,diameter2*scaleAxis],
		[0, Math.PI*2], alpha1,'blue',segments)

}

function drawCylinder(ctx, center, r, h, angle, color, segments) {
	scaleAxis = 0.45
	drawEllipse(context, center,[r,r*scaleAxis], [0, Math.PI*2], angle, color)
	drawEllipse(context, [center[0]-h*Math.sin(angle),center[1]+h*Math.cos(angle)],[r,r*scaleAxis], [0, Math.PI], angle, color)
	ctx.beginPath();

	let left = [center[0]-r*Math.cos(angle),center[1]-r*Math.sin(angle)]
	ctx.moveTo(left[0],left[1])
	ctx.lineTo(left[0]-h*Math.sin(angle),left[1]+h*Math.cos(angle))

	let right = [center[0]+r*Math.cos(angle),center[1]+r*Math.sin(angle)]
	ctx.moveTo(right[0],right[1])
	ctx.lineTo(right[0]-h*Math.sin(angle),right[1]+h*Math.cos(angle))

	ctx.stroke();
	ctx.closePath();
	}

function drawEllipse(ctx, center, sizes, sector, angle, color) {
	ctx.save();                                     // сохраняем стейт контекста
	ctx.beginPath();
	ctx.translate(center[0], center[1]);            // перемещаем координаты в центр эллипса
	ctx.rotate(angle);                              // поворачиваем координатную сетку на нужный угол
	ctx.scale(1, sizes[1]/sizes[0]);                // сжимаем по вертикали
	ctx.arc(0, 0, sizes[0], sector[0], sector[1]);  // рисуем сектор окружности
	ctx.restore();                                  // восстанавливает стейт, иначе обводка и заливка будут сплющенными и повёрнутыми
	ctx.strokeStyle = color;
	ctx.stroke();                                   // обводим
	ctx.closePath();
}

function draw2Ellipse(ctx, center, sizes, sizes2, sector, angle, color, segments) {
	ctx.save();                                     // сохраняем стейт контекста
	ctx.beginPath();
	ctx.translate(center[0], center[1]);            // перемещаем координаты в центр эллипса
	ctx.rotate(angle);                              // поворачиваем координатную сетку на нужный угол
	ctx.scale(1, sizes[1]/sizes[0]);                // сжимаем по вертикали
	// два кольца, можем не рисовать
	// ctx.arc(0, 0, sizes[0], sector[0], sector[1]);  // рисуем сектор окружности
	// ctx.moveTo(sizes2[0],0)
	// ctx.arc(0, 0, sizes2[0],sector[0], sector[1]);  // рисуем сектор окружности

	/* Zigzag between cylinders */

	var x, y, firstTime=true;
	var dt = 2*Math.PI/segments;
	for(var t=0; t < 2*Math.PI; t+=dt) {
		if(firstTime) {
			x = sizes[0]*Math.cos(t);
			y = sizes[0]*Math.sin(t);
			firstTime = false;
			ctx.moveTo(x, y);
			x = sizes2[0]*Math.cos(t+dt/2);
			y = sizes2[0]*Math.sin(t+dt/2);
			ctx.lineTo(x, y);
			} else
		{
			x = sizes[0]*Math.cos(t);
			y = sizes[0]*Math.sin(t);
			ctx.lineTo(x, y);
			x = sizes2[0]*Math.cos(t+dt/2);
			y = sizes2[0]*Math.sin(t+dt/2);
			ctx.lineTo(x, y);
		}
	}
	x = sizes[0]*Math.cos(0);
	y = sizes[0]*Math.sin(t);
	ctx.lineTo(x, y);

	ctx.restore();                                  // восстанавливает стейт, иначе обводка и заливка будут сплющенными и повёрнутыми
	ctx.strokeStyle = color;
	ctx.stroke();                                   // обводим
	ctx.closePath();
}

</script>
/* подумать, как тут поправить. Пока параметры не вводятся  */
<h3 class="special">Calculated parameters:</h3>

		<p class="special">
			Cylinder 1 <br>
			Diameter: <input type="number" id="diameter1" value="diameter1"><br>
			// scale: <input type="number" id="scale" value=1.0>
<p>

</body>
</html>

